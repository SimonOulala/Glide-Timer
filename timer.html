<script>
  // --- Params envoyés par Glide ---
  const q = new URLSearchParams(location.search);
  const prep = Math.max(0, +q.get('prep')||0);   // secondes de préparation
  const dur  = Math.max(0, +q.get('dur')||0);    // secondes de travail
  const startStr = q.get('start');
  const start = startStr ? new Date(startStr).getTime() : Date.now();

  const phaseEl = document.getElementById('phase');
  const timeEl  = document.getElementById('time');

  // --- Utils ---
  const fmt = (s)=>{
    s = Math.max(0, Math.floor(s));
    const m = Math.floor(s/60).toString().padStart(2,'0');
    const sec = (s%60).toString().padStart(2,'0');
    return `${m}:${sec}`;
  };

  // Audio utils
  const shortBeep = (freq=1000, dur=120, vol=0.12)=>{
    try{
      const C = window.AudioContext||window.webkitAudioContext;
      const ctx = new C();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.start(); setTimeout(()=>{o.stop(); ctx.close();}, dur);
    }catch(e){}
  };
  const longBeep = (freq=880, dur=360, vol=0.18)=>{
    try{
      const C = window.AudioContext||window.webkitAudioContext;
      const ctx = new C();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.start(); setTimeout(()=>{o.stop(); ctx.close();}, dur);
    }catch(e){}
  };

  // états pour ne biper qu'une fois par seconde affichée
  let lastPrepDisplay = null;
  let lastRunDisplay  = null;
  let endLongBeepDone = false;

  const renderAndMaybeBeep = ()=>{
    const now = Date.now();
    const elapsed = (now - start)/1000;

    const prepRemain = Math.max(0, prep - elapsed);
    const runRemain  = Math.max(0, prep + dur - elapsed);

    // Phase Prépa
    if (prep > 0 && prepRemain > 0) {
      phaseEl.textContent = "Prépare toi pour l'exercice";
      const disp = Math.floor(prepRemain);     // exactement ce qui est affiché
      timeEl.textContent = fmt(prepRemain);

      if (disp !== lastPrepDisplay) {
        if (disp === 3 || disp === 2 || disp === 1) {
          shortBeep(1000); if (navigator.vibrate) navigator.vibrate(50);
        }
        if (disp === 0) { // bip long sur 0
          longBeep(900, 420, 0.2);
          if (navigator.vibrate) navigator.vibrate([80,40,80]);
        }
        lastPrepDisplay = disp;
      }
      return;
    }

    // Phase Travail
    if (runRemain > 0) {
      phaseEl.textContent = "C'est parti !";
      const disp = Math.floor(runRemain);
      timeEl.textContent = fmt(runRemain);

      if (disp !== lastRunDisplay) {
        if (disp === 3 || disp === 2 || disp === 1) {
          shortBeep(1200); if (navigator.vibrate) navigator.vibrate(50);
        }
        if (disp === 0) { // bip long sur 0
          longBeep(880, 420, 0.2);
          if (navigator.vibrate) navigator.vibrate([100,60,120]);
          endLongBeepDone = true;
        }
        lastRunDisplay = disp;
      }
      return;
    }

    // Terminé
    phaseEl.textContent = "Terminé";
    timeEl.textContent  = "00:00";
    if (!endLongBeepDone) {
      longBeep(880, 420, 0.2);
      if (navigator.vibrate) navigator.vibrate([100,60,120]);
      endLongBeepDone = true;
    }
  };

  // --- métronome calé sur la seconde système ---
  const tickAligned = ()=>{
    renderAndMaybeBeep();
    const now = Date.now();
    // calcule le délai restant jusqu'à la prochaine seconde pleine
    const msToNextSecond = 1000 - ((now - start) % 1000);
    setTimeout(tickAligned, Math.max(80, msToNextSecond)); // jamais < 80ms
  };

  // premier rendu immédiat puis calage exact sur les secondes
  tickAligned();
  // sécurité : au bout de 2h, on stoppe les callbacks
  setTimeout(()=>{ /* noop: navigateur détruira la page bien avant */ }, 2*60*60*1000);
</script>
